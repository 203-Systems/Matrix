   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"dfu.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.dfuInit,"ax",%progbits
  19              		.align	1
  20              		.global	dfuInit
  21              		.thumb
  22              		.thumb_func
  24              	dfuInit:
  25              	.LFB0:
  26              		.file 1 "dfu.c"
   1:dfu.c         **** /* *****************************************************************************
   2:dfu.c         ****  * The MIT License
   3:dfu.c         ****  *
   4:dfu.c         ****  * Copyright (c) 2010 LeafLabs LLC.
   5:dfu.c         ****  *
   6:dfu.c         ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:dfu.c         ****  * of this software and associated documentation files (the "Software"), to deal
   8:dfu.c         ****  * in the Software without restriction, including without limitation the rights
   9:dfu.c         ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:dfu.c         ****  * copies of the Software, and to permit persons to whom the Software is
  11:dfu.c         ****  * furnished to do so, subject to the following conditions:
  12:dfu.c         ****  *
  13:dfu.c         ****  * The above copyright notice and this permission notice shall be included in
  14:dfu.c         ****  * all copies or substantial portions of the Software.
  15:dfu.c         ****  *
  16:dfu.c         ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:dfu.c         ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:dfu.c         ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:dfu.c         ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:dfu.c         ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:dfu.c         ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:dfu.c         ****  * THE SOFTWARE.
  23:dfu.c         ****  * ****************************************************************************/
  24:dfu.c         **** 
  25:dfu.c         **** /**
  26:dfu.c         ****  *  @file dfu.c
  27:dfu.c         ****  *
  28:dfu.c         ****  *  @brief The principle dfu state machine as well as the data
  29:dfu.c         ****  *  transfer callbacks accessed by the usb library
  30:dfu.c         ****  *
  31:dfu.c         ****  *
  32:dfu.c         ****  */
  33:dfu.c         **** #include "hardware.h"
  34:dfu.c         **** #include "dfu.h"
  35:dfu.c         **** #include "usb.h"
  36:dfu.c         **** 
  37:dfu.c         **** /* DFU globals */
  38:dfu.c         **** static volatile u32 userAppAddr = USER_CODE_RAM; /* default RAM user code location */
  39:dfu.c         **** static volatile u32 userAppEnd = RAM_END;
  40:dfu.c         **** static volatile DFUStatus dfuAppStatus;       /* includes state */
  41:dfu.c         **** volatile dfuUploadTypes_t userUploadType = DFU_UPLOAD_NONE;
  42:dfu.c         **** volatile bool dfuBusy = FALSE;
  43:dfu.c         **** 
  44:dfu.c         **** 
  45:dfu.c         **** //static volatile u8 recvBuffer[wTransferSize] __attribute__((aligned(4)));
  46:dfu.c         **** static volatile u8 recvBuffer[LARGEST_FLASH_PAGE_SIZE] __attribute__((aligned(4)));
  47:dfu.c         **** 
  48:dfu.c         **** static volatile u32 userFirmwareLen = 0;
  49:dfu.c         **** static volatile u16 thisBlockLen = 0;
  50:dfu.c         **** static volatile u16 uploadBlockLen = 0;
  51:dfu.c         **** 
  52:dfu.c         **** 
  53:dfu.c         **** volatile PLOT code_copy_lock;
  54:dfu.c         **** 
  55:dfu.c         **** /* todo: force dfu globals to be singleton to avoid re-inits? */
  56:dfu.c         **** void dfuInit(void) {
  27              		.loc 1 56 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  57:dfu.c         ****     dfuAppStatus.bStatus = OK;
  32              		.loc 1 57 0
  33 0000 0D4A     		ldr	r2, .L2
  34 0002 0023     		movs	r3, #0
  58:dfu.c         ****     dfuAppStatus.bwPollTimeout0 = 0x00;
  59:dfu.c         ****     dfuAppStatus.bwPollTimeout1 = 0x00;
  60:dfu.c         ****     dfuAppStatus.bwPollTimeout2 = 0x00;
  61:dfu.c         ****     dfuAppStatus.bState = dfuIDLE;
  35              		.loc 1 61 0
  36 0004 0221     		movs	r1, #2
  57:dfu.c         ****     dfuAppStatus.bStatus = OK;
  37              		.loc 1 57 0
  38 0006 1370     		strb	r3, [r2]
  58:dfu.c         ****     dfuAppStatus.bwPollTimeout0 = 0x00;
  39              		.loc 1 58 0
  40 0008 5370     		strb	r3, [r2, #1]
  59:dfu.c         ****     dfuAppStatus.bwPollTimeout1 = 0x00;
  41              		.loc 1 59 0
  42 000a 9370     		strb	r3, [r2, #2]
  60:dfu.c         ****     dfuAppStatus.bwPollTimeout2 = 0x00;
  43              		.loc 1 60 0
  44 000c D370     		strb	r3, [r2, #3]
  45              		.loc 1 61 0
  46 000e 1171     		strb	r1, [r2, #4]
  62:dfu.c         ****     dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
  47              		.loc 1 62 0
  48 0010 5371     		strb	r3, [r2, #5]
  63:dfu.c         ****     userFirmwareLen = 0;
  49              		.loc 1 63 0
  50 0012 0A4A     		ldr	r2, .L2+4
  64:dfu.c         ****     thisBlockLen = 0;;
  65:dfu.c         ****     userAppAddr = USER_CODE_RAM; /* default RAM user code location */
  51              		.loc 1 65 0
  52 0014 0A49     		ldr	r1, .L2+8
  63:dfu.c         ****     userFirmwareLen = 0;
  53              		.loc 1 63 0
  54 0016 1360     		str	r3, [r2]
  64:dfu.c         ****     thisBlockLen = 0;;
  55              		.loc 1 64 0
  56 0018 0A4A     		ldr	r2, .L2+12
  57 001a 1380     		strh	r3, [r2]	@ movhi
  58              		.loc 1 65 0
  59 001c 0A4A     		ldr	r2, .L2+16
  60 001e 1160     		str	r1, [r2]
  66:dfu.c         ****     userAppEnd = RAM_END;
  61              		.loc 1 66 0
  62 0020 0A4A     		ldr	r2, .L2+20
  63 0022 01F58841 		add	r1, r1, #17408
  64 0026 1160     		str	r1, [r2]
  67:dfu.c         ****     userUploadType=DFU_UPLOAD_NONE;
  65              		.loc 1 67 0
  66 0028 094A     		ldr	r2, .L2+24
  68:dfu.c         ****     code_copy_lock = WAIT;
  67              		.loc 1 68 0
  68 002a 0321     		movs	r1, #3
  67:dfu.c         ****     userUploadType=DFU_UPLOAD_NONE;
  69              		.loc 1 67 0
  70 002c 1370     		strb	r3, [r2]
  71              		.loc 1 68 0
  72 002e 094A     		ldr	r2, .L2+28
  73 0030 1170     		strb	r1, [r2]
  69:dfu.c         ****     dfuBusy = FALSE;
  74              		.loc 1 69 0
  75 0032 094A     		ldr	r2, .L2+32
  76 0034 1370     		strb	r3, [r2]
  77 0036 7047     		bx	lr
  78              	.L3:
  79              		.align	2
  80              	.L2:
  81 0038 00000000 		.word	.LANCHOR0
  82 003c 00000000 		.word	.LANCHOR1
  83 0040 000C0020 		.word	536873984
  84 0044 00000000 		.word	.LANCHOR2
  85 0048 00000000 		.word	.LANCHOR3
  86 004c 00000000 		.word	.LANCHOR4
  87 0050 00000000 		.word	.LANCHOR5
  88 0054 00000000 		.word	code_copy_lock
  89 0058 00000000 		.word	.LANCHOR6
  90              		.cfi_endproc
  91              	.LFE0:
  93              		.section	.text.dfuUpdateByReset,"ax",%progbits
  94              		.align	1
  95              		.global	dfuUpdateByReset
  96              		.thumb
  97              		.thumb_func
  99              	dfuUpdateByReset:
 100              	.LFB2:
  70:dfu.c         **** }
  71:dfu.c         **** 
  72:dfu.c         **** 
  73:dfu.c         **** 
  74:dfu.c         **** 
  75:dfu.c         **** bool dfuUpdateByRequest(void) {
  76:dfu.c         ****     /* were using the global pInformation struct from usb_lib here,
  77:dfu.c         ****        see comment in maple_dfu.h around DFUEvent struct */
  78:dfu.c         ****     dfuBusy = TRUE;
  79:dfu.c         **** 
  80:dfu.c         **** 
  81:dfu.c         **** 
  82:dfu.c         ****     u8 startState = dfuAppStatus.bState;
  83:dfu.c         ****     dfuAppStatus.bStatus = OK;
  84:dfu.c         ****     /* often leaner to nest if's then embed a switch/case */
  85:dfu.c         ****     if (startState == dfuIDLE)  {
  86:dfu.c         ****         /*  device running inside DFU mode */
  87:dfu.c         ****         dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
  88:dfu.c         **** 
  89:dfu.c         ****         if (pInformation->USBbRequest == DFU_DNLOAD) {
  90:dfu.c         **** 
  91:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
  92:dfu.c         ****                 userFirmwareLen = 0;
  93:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
  94:dfu.c         ****                 switch(pInformation->Current_AlternateSetting)
  95:dfu.c         ****                 {
  96:dfu.c         ****                     /*
  97:dfu.c         ****                     Roger Clark. removed upload to RAM option
  98:dfu.c         ****                     case 0:
  99:dfu.c         ****                         userAppAddr = USER_CODE_RAM;
 100:dfu.c         ****                         userUploadType = DFU_UPLOAD_RAM;
 101:dfu.c         ****                         break;
 102:dfu.c         ****                         */
 103:dfu.c         ****                     #ifdef MATRIX
 104:dfu.c         ****                     case 0:
 105:dfu.c         ****                         userUploadType = DFU_UPLOAD_FLASH_0X8002000;
 106:dfu.c         ****                         userAppAddr = USER_CODE_FLASH0X8002000;
 107:dfu.c         ****                         /* make sure the flash is setup properly, unlock it */
 108:dfu.c         ****                         setupFLASH();
 109:dfu.c         ****                         flashUnlock();
 110:dfu.c         ****                         bkp10Write(RTC_BOOTLOADER_JUST_UPLOADED);
 111:dfu.c         **** 
 112:dfu.c         ****                         break;
 113:dfu.c         ****                     // case 1:
 114:dfu.c         ****                     //
 115:dfu.c         ****                     //         userAppAddr = USER_CODE_FLASH0X8005000;
 116:dfu.c         ****                     //         userUploadType = DFU_UPLOAD_FLASH_0X8000000;
 117:dfu.c         ****                     //
 118:dfu.c         ****                     //         /* make sure the flash is setup properly, unlock it */
 119:dfu.c         ****                     //         setupFLASH();
 120:dfu.c         ****                     //         flashUnlock();
 121:dfu.c         ****                     //         // Clear lower memory so that we can check on cold boot, whether the
 122:dfu.c         ****                     //         flashErasePage((u32)USER_CODE_FLASH0X8002000);
 123:dfu.c         ****                     //         bkp10Write(RTC_BOOTLOADER_JUST_UPLOADED);
 124:dfu.c         ****                     //
 125:dfu.c         ****                     //         break;
 126:dfu.c         ****                     #else
 127:dfu.c         ****                     case 1:
 128:dfu.c         **** 
 129:dfu.c         ****                         userAppAddr = USER_CODE_FLASH0X8005000;
 130:dfu.c         ****                         userUploadType = DFU_UPLOAD_FLASH_0X8005000;
 131:dfu.c         **** 
 132:dfu.c         ****                         /* make sure the flash is setup properly, unlock it */
 133:dfu.c         ****                         setupFLASH();
 134:dfu.c         ****                         flashUnlock();
 135:dfu.c         ****                         // Clear lower memory so that we can check on cold boot, whether the last u
 136:dfu.c         ****                         flashErasePage((u32)USER_CODE_FLASH0X8002000);
 137:dfu.c         ****                         bkp10Write(RTC_BOOTLOADER_JUST_UPLOADED);
 138:dfu.c         **** 
 139:dfu.c         ****                         break;
 140:dfu.c         ****                     case 2:
 141:dfu.c         ****                         userUploadType = DFU_UPLOAD_FLASH_0X8002000;
 142:dfu.c         ****                         userAppAddr = USER_CODE_FLASH0X8002000;
 143:dfu.c         ****                         /* make sure the flash is setup properly, unlock it */
 144:dfu.c         ****                         setupFLASH();
 145:dfu.c         ****                         flashUnlock();
 146:dfu.c         ****                         bkp10Write(RTC_BOOTLOADER_JUST_UPLOADED);
 147:dfu.c         **** 
 148:dfu.c         ****                         break;
 149:dfu.c         ****                     #endif
 150:dfu.c         **** 
 151:dfu.c         ****                     default:
 152:dfu.c         ****                     // Roger Clark. Report error
 153:dfu.c         ****                         dfuAppStatus.bState  = dfuERROR;
 154:dfu.c         ****                         dfuAppStatus.bStatus = errWRITE;
 155:dfu.c         ****                         break;
 156:dfu.c         ****                 }
 157:dfu.c         ****             } else {
 158:dfu.c         ****                 dfuAppStatus.bState  = dfuERROR;
 159:dfu.c         ****                 dfuAppStatus.bStatus = errNOTDONE;
 160:dfu.c         ****             }
 161:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_UPLOAD) {
 162:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 163:dfu.c         ****             /* record length of first block for calculating target
 164:dfu.c         ****                address from wValue in consecutive blocks */
 165:dfu.c         ****             uploadBlockLen = pInformation->USBwLengths.w;
 166:dfu.c         ****             thisBlockLen = uploadBlockLen; /* for this first block as well */
 167:dfu.c         ****             /* calculate where the data should be copied from */
 168:dfu.c         ****             userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 169:dfu.c         ****             switch(pInformation->Current_AlternateSetting)
 170:dfu.c         ****             {
 171:dfu.c         ****             /*
 172:dfu.c         ****                 case 0:
 173:dfu.c         ****                     userAppAddr = USER_CODE_RAM;
 174:dfu.c         ****                     userAppEnd = RAM_END;
 175:dfu.c         ****                     */
 176:dfu.c         ****                 #ifdef Matrix
 177:dfu.c         ****                 case 0:
 178:dfu.c         ****                     userAppAddr = USER_CODE_FLASH0X8002000;
 179:dfu.c         ****                     userAppEnd = getFlashEnd();
 180:dfu.c         ****                     break;
 181:dfu.c         ****                 // case 1:
 182:dfu.c         ****                 //     userAppAddr = USER_CODE_FLASH0X8000000;
 183:dfu.c         ****                 //     userAppEnd = USER_CODE_FLASH0X8002000;
 184:dfu.c         ****                 //     break;
 185:dfu.c         ****                 #else
 186:dfu.c         ****                 case 1:
 187:dfu.c         ****                     userAppAddr = USER_CODE_FLASH0X8005000;
 188:dfu.c         ****                     userAppEnd = getFlashEnd();
 189:dfu.c         ****                     break;
 190:dfu.c         ****                 case 2:
 191:dfu.c         ****                     userAppAddr = USER_CODE_FLASH0X8002000;
 192:dfu.c         ****                     userAppEnd = getFlashEnd();
 193:dfu.c         ****                     break;
 194:dfu.c         ****                 #endif
 195:dfu.c         ****                 default:
 196:dfu.c         ****                 // Roger Clark.
 197:dfu.c         ****                 // Changed this to report error that its unable to write to this memory
 198:dfu.c         ****                 // However the code should never get here as only AlternateSetting 1 and 2 are allo
 199:dfu.c         ****                     dfuAppStatus.bState  = dfuERROR;
 200:dfu.c         ****                     dfuAppStatus.bStatus = errWRITE;
 201:dfu.c         ****                     break;
 202:dfu.c         ****             }
 203:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 204:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 205:dfu.c         ****             dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
 206:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 207:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 208:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 209:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 210:dfu.c         ****         } else {
 211:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 212:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 213:dfu.c         ****         }
 214:dfu.c         **** 
 215:dfu.c         ****     } else if (startState == dfuDNLOAD_SYNC)         {
 216:dfu.c         ****         /* device received block, waiting for DFU_GETSTATUS request */
 217:dfu.c         **** 
 218:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 219:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 220:dfu.c         **** 
 221:dfu.c         ****             /* Roger Clark. Commented out code associated with RAM upload
 222:dfu.c         **** 
 223:dfu.c         ****             if (userUploadType == DFU_UPLOAD_RAM)
 224:dfu.c         ****             {
 225:dfu.c         ****                 if (code_copy_lock == WAIT) {
 226:dfu.c         ****                     code_copy_lock = BEGINNING;
 227:dfu.c         ****                     dfuAppStatus.bwPollTimeout0 = 0x20; // 32 ms
 228:dfu.c         ****                     dfuAppStatus.bwPollTimeout1 = 0x00;
 229:dfu.c         ****                     dfuAppStatus.bState = dfuDNBUSY;
 230:dfu.c         **** 
 231:dfu.c         ****                 } else if (code_copy_lock == BEGINNING) {
 232:dfu.c         ****                     dfuAppStatus.bState = dfuDNLOAD_SYNC;
 233:dfu.c         **** 
 234:dfu.c         ****                 } else if (code_copy_lock == MIDDLE) {
 235:dfu.c         ****                     dfuAppStatus.bState = dfuDNLOAD_SYNC;
 236:dfu.c         **** 
 237:dfu.c         ****                 } else if (code_copy_lock == END) {
 238:dfu.c         ****                     dfuAppStatus.bwPollTimeout0 = 0x00;
 239:dfu.c         ****                     code_copy_lock = WAIT;
 240:dfu.c         ****                     dfuAppStatus.bState = dfuDNLOAD_IDLE;
 241:dfu.c         ****                 }
 242:dfu.c         **** 
 243:dfu.c         ****             }
 244:dfu.c         ****             else
 245:dfu.c         ****             */
 246:dfu.c         ****             {
 247:dfu.c         ****                 dfuAppStatus.bState = dfuDNLOAD_IDLE;
 248:dfu.c         ****                 dfuCopyBufferToExec();
 249:dfu.c         ****             }
 250:dfu.c         **** 
 251:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 252:dfu.c         ****             dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 253:dfu.c         ****         } else {
 254:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 255:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 256:dfu.c         ****         }
 257:dfu.c         **** 
 258:dfu.c         ****     } else if (startState == dfuDNBUSY)              {
 259:dfu.c         ****         /* if were actually done writing, goto sync, else stay busy */
 260:dfu.c         ****         if (code_copy_lock == END) {
 261:dfu.c         ****             dfuAppStatus.bwPollTimeout0 = 0x00;
 262:dfu.c         ****             code_copy_lock = WAIT;
 263:dfu.c         ****             dfuAppStatus.bState = dfuDNLOAD_IDLE;
 264:dfu.c         ****         } else {
 265:dfu.c         ****             dfuAppStatus.bState = dfuDNBUSY;
 266:dfu.c         ****         }
 267:dfu.c         **** 
 268:dfu.c         ****     } else if (startState == dfuDNLOAD_IDLE)         {
 269:dfu.c         ****         /* device is expecting dfu_dnload requests */
 270:dfu.c         ****         if (pInformation->USBbRequest == DFU_DNLOAD) {
 271:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 272:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 273:dfu.c         ****             } else {
 274:dfu.c         ****                 /* todo, support "disagreement" if device expects more data than this */
 275:dfu.c         ****                 dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 276:dfu.c         **** 
 277:dfu.c         ****                 /* relock the flash */
 278:dfu.c         ****                 flashLock();
 279:dfu.c         ****             }
 280:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 281:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 282:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 283:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 284:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 285:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 286:dfu.c         ****         } else {
 287:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 288:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 289:dfu.c         ****         }
 290:dfu.c         **** 
 291:dfu.c         ****     } else if (startState == dfuMANIFEST_SYNC)       {
 292:dfu.c         ****         /* device has received last block, waiting DFU_GETSTATUS request */
 293:dfu.c         **** 
 294:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 295:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 296:dfu.c         ****             dfuAppStatus.bStatus = OK;
 297:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 298:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 299:dfu.c         ****         } else {
 300:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 301:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 302:dfu.c         ****         }
 303:dfu.c         **** 
 304:dfu.c         ****     } else if (startState == dfuMANIFEST)            {
 305:dfu.c         ****         /* device is in manifestation phase */
 306:dfu.c         **** 
 307:dfu.c         ****         /* should never receive request while in manifest! */
 308:dfu.c         ****         dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 309:dfu.c         ****         dfuAppStatus.bStatus = OK;
 310:dfu.c         **** 
 311:dfu.c         ****     } else if (startState == dfuMANIFEST_WAIT_RESET) {
 312:dfu.c         ****         /* device has programmed new firmware but needs external
 313:dfu.c         ****            usb reset or power on reset to run the new code */
 314:dfu.c         **** 
 315:dfu.c         ****         /* consider timing out and self-resetting */
 316:dfu.c         ****         dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 317:dfu.c         **** 
 318:dfu.c         ****     } else if (startState == dfuUPLOAD_IDLE)         {
 319:dfu.c         ****         /* device expecting further dfu_upload requests */
 320:dfu.c         **** 
 321:dfu.c         ****         if (pInformation->USBbRequest == DFU_UPLOAD) {
 322:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 323:dfu.c         ****                 /* check that this is not the last possible block */
 324:dfu.c         ****                 userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 325:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 326:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 327:dfu.c         ****                     dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 328:dfu.c         ****                 } else {
 329:dfu.c         ****                     /* if above comparison was just equal, thisBlockLen becomes zero
 330:dfu.c         ****                     next time when USBWValue has been increased by one */
 331:dfu.c         ****                     thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
 332:dfu.c         ****                     /* check for overflow due to USBwValue out of range */
 333:dfu.c         ****                     if (thisBlockLen >= pInformation->USBwLengths.w) {
 334:dfu.c         ****                         thisBlockLen = 0;
 335:dfu.c         ****                     }
 336:dfu.c         ****                     dfuAppStatus.bState  = dfuIDLE;
 337:dfu.c         ****                 }
 338:dfu.c         ****             } else {
 339:dfu.c         ****                 dfuAppStatus.bState  = dfuERROR;
 340:dfu.c         ****                 dfuAppStatus.bStatus = errNOTDONE;
 341:dfu.c         ****             }
 342:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 343:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 344:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 345:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 346:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 347:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 348:dfu.c         ****         } else {
 349:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 350:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 351:dfu.c         ****         }
 352:dfu.c         **** 
 353:dfu.c         **** 
 354:dfu.c         ****     } else if (startState == dfuERROR)               {
 355:dfu.c         ****         /* status is in error, awaiting DFU_CLRSTATUS request */
 356:dfu.c         **** 
 357:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 358:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 359:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 360:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 361:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 362:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
 363:dfu.c         ****             /* todo handle any cleanup we need here */
 364:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 365:dfu.c         ****             dfuAppStatus.bStatus = OK;
 366:dfu.c         ****         } else {
 367:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 368:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 369:dfu.c         ****         }
 370:dfu.c         **** 
 371:dfu.c         ****     } else {
 372:dfu.c         ****         /* some kind of error... */
 373:dfu.c         ****         dfuAppStatus.bState  = dfuERROR;
 374:dfu.c         ****         dfuAppStatus.bStatus = errSTALLEDPKT;
 375:dfu.c         ****     }
 376:dfu.c         **** 
 377:dfu.c         ****     if (dfuAppStatus.bStatus == OK) {
 378:dfu.c         ****         return TRUE;
 379:dfu.c         ****     } else {
 380:dfu.c         ****         return FALSE;
 381:dfu.c         ****     }
 382:dfu.c         **** }
 383:dfu.c         **** 
 384:dfu.c         **** void dfuUpdateByReset(void) {
 101              		.loc 1 384 0
 102              		.cfi_startproc
 103              		@ args = 0, pretend = 0, frame = 0
 104              		@ frame_needed = 0, uses_anonymous_args = 0
 105 0000 08B5     		push	{r3, lr}
 106              		.cfi_def_cfa_offset 8
 107              		.cfi_offset 3, -8
 108              		.cfi_offset 14, -4
 385:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 109              		.loc 1 385 0
 110 0002 0E4B     		ldr	r3, .L8
 386:dfu.c         ****     userFirmwareLen = 0;
 111              		.loc 1 386 0
 112 0004 0E48     		ldr	r0, .L8+4
 385:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 113              		.loc 1 385 0
 114 0006 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 115              		.loc 1 386 0
 116 0008 0022     		movs	r2, #0
 385:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 117              		.loc 1 385 0
 118 000a C9B2     		uxtb	r1, r1
 119              	.LVL0:
 387:dfu.c         **** 
 388:dfu.c         ****     if (startState == appDETACH) {
 120              		.loc 1 388 0
 121 000c 0129     		cmp	r1, #1
 386:dfu.c         ****     userFirmwareLen = 0;
 122              		.loc 1 386 0
 123 000e 0260     		str	r2, [r0]
 124              		.loc 1 388 0
 125 0010 08D1     		bne	.L5
 389:dfu.c         ****         dfuAppStatus.bState = dfuIDLE;
 126              		.loc 1 389 0
 127 0012 0221     		movs	r1, #2
 128              	.LVL1:
 129 0014 1971     		strb	r1, [r3, #4]
 390:dfu.c         ****         dfuAppStatus.bStatus = OK;
 130              		.loc 1 390 0
 131 0016 1A70     		strb	r2, [r3]
 391:dfu.c         **** 
 392:dfu.c         ****         nvicDisableInterrupts();
 132              		.loc 1 392 0
 133 0018 FFF7FEFF 		bl	nvicDisableInterrupts
 134              	.LVL2:
 393:dfu.c         ****         usbEnbISR();
 394:dfu.c         **** 
 395:dfu.c         ****     } else if (startState == appIDLE || startState == dfuIDLE) {
 396:dfu.c         ****         /* do nothing...might be normal usb bus activity */
 397:dfu.c         ****     } else {
 398:dfu.c         ****         /* we reset from the dfu, reset everything and startover,
 399:dfu.c         ****            which is the correct operation if this is an erroneous
 400:dfu.c         ****            event or properly following a MANIFEST */
 401:dfu.c         ****         dfuAppStatus.bState = dfuIDLE;
 402:dfu.c         ****         dfuAppStatus.bStatus = OK;
 403:dfu.c         **** 
 404:dfu.c         ****         systemHardReset();
 405:dfu.c         ****     }
 406:dfu.c         **** }
 135              		.loc 1 406 0
 136 001c BDE80840 		pop	{r3, lr}
 393:dfu.c         ****         usbEnbISR();
 137              		.loc 1 393 0
 138 0020 FFF7FEBF 		b	usbEnbISR
 139              	.LVL3:
 140              	.L5:
 395:dfu.c         ****     } else if (startState == appIDLE || startState == dfuIDLE) {
 141              		.loc 1 395 0
 142 0024 11F0FD0F 		tst	r1, #253
 143 0028 06D0     		beq	.L4
 401:dfu.c         ****         dfuAppStatus.bState = dfuIDLE;
 144              		.loc 1 401 0
 145 002a 0221     		movs	r1, #2
 146              	.LVL4:
 147 002c 1971     		strb	r1, [r3, #4]
 402:dfu.c         ****         dfuAppStatus.bStatus = OK;
 148              		.loc 1 402 0
 149 002e 1A70     		strb	r2, [r3]
 150              		.loc 1 406 0
 151 0030 BDE80840 		pop	{r3, lr}
 404:dfu.c         ****         systemHardReset();
 152              		.loc 1 404 0
 153 0034 FFF7FEBF 		b	systemHardReset
 154              	.LVL5:
 155              	.L4:
 156 0038 08BD     		pop	{r3, pc}
 157              	.L9:
 158 003a 00BF     		.align	2
 159              	.L8:
 160 003c 00000000 		.word	.LANCHOR0
 161 0040 00000000 		.word	.LANCHOR1
 162              		.cfi_endproc
 163              	.LFE2:
 165              		.section	.text.dfuUpdateByTimeout,"ax",%progbits
 166              		.align	1
 167              		.global	dfuUpdateByTimeout
 168              		.thumb
 169              		.thumb_func
 171              	dfuUpdateByTimeout:
 172              	.LFB3:
 407:dfu.c         **** 
 408:dfu.c         **** void dfuUpdateByTimeout(void) {
 173              		.loc 1 408 0
 174              		.cfi_startproc
 175              		@ args = 0, pretend = 0, frame = 0
 176              		@ frame_needed = 0, uses_anonymous_args = 0
 177              		@ link register save eliminated.
 178 0000 7047     		bx	lr
 179              		.cfi_endproc
 180              	.LFE3:
 182              		.section	.text.dfuCopyState,"ax",%progbits
 183              		.align	1
 184              		.global	dfuCopyState
 185              		.thumb
 186              		.thumb_func
 188              	dfuCopyState:
 189              	.LFB4:
 409:dfu.c         **** }
 410:dfu.c         **** 
 411:dfu.c         **** u8 *dfuCopyState(u16 length) {
 190              		.loc 1 411 0
 191              		.cfi_startproc
 192              		@ args = 0, pretend = 0, frame = 0
 193              		@ frame_needed = 0, uses_anonymous_args = 0
 194              		@ link register save eliminated.
 195              	.LVL6:
 412:dfu.c         ****     if (length == 0) {
 196              		.loc 1 412 0
 197 0000 20B9     		cbnz	r0, .L13
 413:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = 1;
 198              		.loc 1 413 0
 199 0002 034B     		ldr	r3, .L14
 200 0004 0122     		movs	r2, #1
 201 0006 1B68     		ldr	r3, [r3]
 202 0008 1A82     		strh	r2, [r3, #16]	@ movhi
 414:dfu.c         ****         return NULL;
 203              		.loc 1 414 0
 204 000a 7047     		bx	lr
 205              	.L13:
 415:dfu.c         ****     } else {
 416:dfu.c         ****         return (&(dfuAppStatus.bState));
 206              		.loc 1 416 0
 207 000c 0148     		ldr	r0, .L14+4
 208              	.LVL7:
 417:dfu.c         ****     }
 418:dfu.c         **** }
 209              		.loc 1 418 0
 210 000e 7047     		bx	lr
 211              	.L15:
 212              		.align	2
 213              	.L14:
 214 0010 00000000 		.word	pInformation
 215 0014 04000000 		.word	.LANCHOR0+4
 216              		.cfi_endproc
 217              	.LFE4:
 219              		.section	.text.dfuCopyStatus,"ax",%progbits
 220              		.align	1
 221              		.global	dfuCopyStatus
 222              		.thumb
 223              		.thumb_func
 225              	dfuCopyStatus:
 226              	.LFB5:
 419:dfu.c         **** 
 420:dfu.c         **** u8 *dfuCopyStatus(u16 length) {
 227              		.loc 1 420 0
 228              		.cfi_startproc
 229              		@ args = 0, pretend = 0, frame = 0
 230              		@ frame_needed = 0, uses_anonymous_args = 0
 231              		@ link register save eliminated.
 232              	.LVL8:
 421:dfu.c         ****     if (length == 0) {
 233              		.loc 1 421 0
 234 0000 20B9     		cbnz	r0, .L18
 422:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = 6;
 235              		.loc 1 422 0
 236 0002 034B     		ldr	r3, .L19
 237 0004 0622     		movs	r2, #6
 238 0006 1B68     		ldr	r3, [r3]
 239 0008 1A82     		strh	r2, [r3, #16]	@ movhi
 423:dfu.c         ****         return NULL;
 240              		.loc 1 423 0
 241 000a 7047     		bx	lr
 242              	.L18:
 424:dfu.c         ****     } else {
 425:dfu.c         ****         return (u8*)(&dfuAppStatus);
 243              		.loc 1 425 0
 244 000c 0148     		ldr	r0, .L19+4
 245              	.LVL9:
 426:dfu.c         ****     }
 427:dfu.c         **** }
 246              		.loc 1 427 0
 247 000e 7047     		bx	lr
 248              	.L20:
 249              		.align	2
 250              	.L19:
 251 0010 00000000 		.word	pInformation
 252 0014 00000000 		.word	.LANCHOR0
 253              		.cfi_endproc
 254              	.LFE5:
 256              		.section	.text.dfuCopyDNLOAD,"ax",%progbits
 257              		.align	1
 258              		.global	dfuCopyDNLOAD
 259              		.thumb
 260              		.thumb_func
 262              	dfuCopyDNLOAD:
 263              	.LFB6:
 428:dfu.c         **** 
 429:dfu.c         **** 
 430:dfu.c         **** u8 *dfuCopyDNLOAD(u16 length) {
 264              		.loc 1 430 0
 265              		.cfi_startproc
 266              		@ args = 0, pretend = 0, frame = 0
 267              		@ frame_needed = 0, uses_anonymous_args = 0
 268              		@ link register save eliminated.
 269              	.LVL10:
 270 0000 064B     		ldr	r3, .L24
 431:dfu.c         ****     if (length == 0) {
 432:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info
 271              		.loc 1 432 0
 272 0002 1B68     		ldr	r3, [r3]
 431:dfu.c         ****     if (length == 0) {
 273              		.loc 1 431 0
 274 0004 30B9     		cbnz	r0, .L22
 275              		.loc 1 432 0
 276 0006 DA88     		ldrh	r2, [r3, #6]
 277 0008 598A     		ldrh	r1, [r3, #18]
 278 000a 511A     		subs	r1, r2, r1
 279 000c 1982     		strh	r1, [r3, #16]	@ movhi
 433:dfu.c         ****         thisBlockLen = pInformation->USBwLengths.w;
 280              		.loc 1 433 0
 281 000e 044B     		ldr	r3, .L24+4
 282 0010 1A80     		strh	r2, [r3]	@ movhi
 434:dfu.c         ****         return NULL;
 283              		.loc 1 434 0
 284 0012 7047     		bx	lr
 285              	.L22:
 435:dfu.c         ****     } else {
 436:dfu.c         ****         return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
 286              		.loc 1 436 0
 287 0014 5B8A     		ldrh	r3, [r3, #18]
 288 0016 0348     		ldr	r0, .L24+8
 289              	.LVL11:
 290 0018 1844     		add	r0, r0, r3
 437:dfu.c         ****     }
 438:dfu.c         **** }
 291              		.loc 1 438 0
 292 001a 7047     		bx	lr
 293              	.L25:
 294              		.align	2
 295              	.L24:
 296 001c 00000000 		.word	pInformation
 297 0020 00000000 		.word	.LANCHOR2
 298 0024 00000000 		.word	.LANCHOR7
 299              		.cfi_endproc
 300              	.LFE6:
 302              		.section	.text.dfuCopyUPLOAD,"ax",%progbits
 303              		.align	1
 304              		.global	dfuCopyUPLOAD
 305              		.thumb
 306              		.thumb_func
 308              	dfuCopyUPLOAD:
 309              	.LFB7:
 439:dfu.c         **** 
 440:dfu.c         **** u8 *dfuCopyUPLOAD(u16 length) {
 310              		.loc 1 440 0
 311              		.cfi_startproc
 312              		@ args = 0, pretend = 0, frame = 0
 313              		@ frame_needed = 0, uses_anonymous_args = 0
 314              		@ link register save eliminated.
 315              	.LVL12:
 316 0000 084B     		ldr	r3, .L29
 441:dfu.c         ****     if (length == 0) {
 317              		.loc 1 441 0
 318 0002 30B9     		cbnz	r0, .L27
 442:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
 319              		.loc 1 442 0
 320 0004 1B68     		ldr	r3, [r3]
 321 0006 084A     		ldr	r2, .L29+4
 322 0008 1188     		ldrh	r1, [r2]
 323 000a 5A8A     		ldrh	r2, [r3, #18]
 324 000c 8A1A     		subs	r2, r1, r2
 325 000e 1A82     		strh	r2, [r3, #16]	@ movhi
 443:dfu.c         ****         return NULL;
 326              		.loc 1 443 0
 327 0010 7047     		bx	lr
 328              	.L27:
 444:dfu.c         ****     } else {
 445:dfu.c         ****         return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
 329              		.loc 1 445 0
 330 0012 0649     		ldr	r1, .L29+8
 331 0014 064A     		ldr	r2, .L29+12
 332 0016 1B68     		ldr	r3, [r3]
 333 0018 1268     		ldr	r2, [r2]
 334 001a 0868     		ldr	r0, [r1]
 335              	.LVL13:
 336 001c 5B8A     		ldrh	r3, [r3, #18]
 337 001e 1044     		add	r0, r0, r2
 338 0020 1844     		add	r0, r0, r3
 446:dfu.c         ****     }
 447:dfu.c         **** }
 339              		.loc 1 447 0
 340 0022 7047     		bx	lr
 341              	.L30:
 342              		.align	2
 343              	.L29:
 344 0024 00000000 		.word	pInformation
 345 0028 00000000 		.word	.LANCHOR2
 346 002c 00000000 		.word	.LANCHOR3
 347 0030 00000000 		.word	.LANCHOR1
 348              		.cfi_endproc
 349              	.LFE7:
 351              		.section	.text.dfuCopyBufferToExec,"ax",%progbits
 352              		.align	1
 353              		.global	dfuCopyBufferToExec
 354              		.thumb
 355              		.thumb_func
 357              	dfuCopyBufferToExec:
 358              	.LFB8:
 448:dfu.c         **** 
 449:dfu.c         **** void dfuCopyBufferToExec() {
 359              		.loc 1 449 0
 360              		.cfi_startproc
 361              		@ args = 0, pretend = 0, frame = 0
 362              		@ frame_needed = 0, uses_anonymous_args = 0
 363 0000 70B5     		push	{r4, r5, r6, lr}
 364              		.cfi_def_cfa_offset 16
 365              		.cfi_offset 4, -16
 366              		.cfi_offset 5, -12
 367              		.cfi_offset 6, -8
 368              		.cfi_offset 14, -4
 450:dfu.c         ****     int i;
 451:dfu.c         ****     u32 *userSpace;
 452:dfu.c         **** 
 453:dfu.c         **** /* Roger Clark.
 454:dfu.c         ****     Commented out code associated with upload to RAM
 455:dfu.c         **** 
 456:dfu.c         ****     if (userUploadType == DFU_UPLOAD_RAM)
 457:dfu.c         ****     {
 458:dfu.c         ****         userSpace = (u32 *)(USER_CODE_RAM + userFirmwareLen);
 459:dfu.c         ****         // we dont need to handle when thisBlock len is not divisible by 4,
 460:dfu.c         ****         //   since the linker will align everything to 4B anyway
 461:dfu.c         ****         for (i = 0; i < thisBlockLen; i = i + 4) {
 462:dfu.c         ****             *userSpace++ = *(u32 *)(recvBuffer + i);
 463:dfu.c         ****         }
 464:dfu.c         ****     }
 465:dfu.c         ****     else
 466:dfu.c         **** */
 467:dfu.c         ****     {
 468:dfu.c         ****         if (userUploadType == DFU_UPLOAD_FLASH_0X8005000)
 369              		.loc 1 468 0
 370 0002 124B     		ldr	r3, .L37
 371 0004 124E     		ldr	r6, .L37+4
 372 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 469:dfu.c         ****         {
 470:dfu.c         ****             userSpace = (u32 *)(USER_CODE_FLASH0X8005000 + userFirmwareLen);
 373              		.loc 1 470 0
 374 0008 3468     		ldr	r4, [r6]
 468:dfu.c         ****         if (userUploadType == DFU_UPLOAD_FLASH_0X8005000)
 375              		.loc 1 468 0
 376 000a 022B     		cmp	r3, #2
 377              		.loc 1 470 0
 378 000c 04F10064 		add	r4, r4, #134217728
 379 0010 0CBF     		ite	eq
 380 0012 04F5A044 		addeq	r4, r4, #20480
 381              	.LVL14:
 471:dfu.c         ****         }
 472:dfu.c         ****         else
 473:dfu.c         ****         {
 474:dfu.c         ****             userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);
 382              		.loc 1 474 0
 383 0016 04F50054 		addne	r4, r4, #8192
 475:dfu.c         ****         }
 476:dfu.c         **** 
 477:dfu.c         ****         flashErasePage((u32)(userSpace));
 384              		.loc 1 477 0
 385 001a 2046     		mov	r0, r4
 386 001c FFF7FEFF 		bl	flashErasePage
 387              	.LVL15:
 478:dfu.c         **** 
 479:dfu.c         ****         for (i = 0; i < thisBlockLen; i = i + 4) {
 388              		.loc 1 479 0
 389 0020 0025     		movs	r5, #0
 390              	.LVL16:
 391              	.L34:
 392              		.loc 1 479 0 is_stmt 0 discriminator 1
 393 0022 0C4B     		ldr	r3, .L37+8
 394 0024 1A88     		ldrh	r2, [r3]
 395 0026 92B2     		uxth	r2, r2
 396 0028 9542     		cmp	r5, r2
 397 002a 06DA     		bge	.L36
 480:dfu.c         ****             flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
 398              		.loc 1 480 0 is_stmt 1 discriminator 2
 399 002c 0A4B     		ldr	r3, .L37+12
 400 002e 6019     		adds	r0, r4, r5
 401 0030 E958     		ldr	r1, [r5, r3]
 402 0032 FFF7FEFF 		bl	flashWriteWord
 403              	.LVL17:
 479:dfu.c         ****         for (i = 0; i < thisBlockLen; i = i + 4) {
 404              		.loc 1 479 0 discriminator 2
 405 0036 0435     		adds	r5, r5, #4
 406              	.LVL18:
 407 0038 F3E7     		b	.L34
 408              	.L36:
 481:dfu.c         ****         }
 482:dfu.c         **** 
 483:dfu.c         ****     }
 484:dfu.c         ****     userFirmwareLen += thisBlockLen;
 409              		.loc 1 484 0
 410 003a 3168     		ldr	r1, [r6]
 411 003c 1A88     		ldrh	r2, [r3]
 412 003e 92B2     		uxth	r2, r2
 413 0040 0A44     		add	r2, r2, r1
 414 0042 3260     		str	r2, [r6]
 485:dfu.c         **** 
 486:dfu.c         ****     thisBlockLen = 0;
 415              		.loc 1 486 0
 416 0044 0022     		movs	r2, #0
 417 0046 1A80     		strh	r2, [r3]	@ movhi
 418 0048 70BD     		pop	{r4, r5, r6, pc}
 419              	.LVL19:
 420              	.L38:
 421 004a 00BF     		.align	2
 422              	.L37:
 423 004c 00000000 		.word	.LANCHOR5
 424 0050 00000000 		.word	.LANCHOR1
 425 0054 00000000 		.word	.LANCHOR2
 426 0058 00000000 		.word	.LANCHOR7
 427              		.cfi_endproc
 428              	.LFE8:
 430              		.section	.text.dfuUpdateByRequest,"ax",%progbits
 431              		.align	1
 432              		.global	dfuUpdateByRequest
 433              		.thumb
 434              		.thumb_func
 436              	dfuUpdateByRequest:
 437              	.LFB1:
  75:dfu.c         **** bool dfuUpdateByRequest(void) {
 438              		.loc 1 75 0
 439              		.cfi_startproc
 440              		@ args = 0, pretend = 0, frame = 0
 441              		@ frame_needed = 0, uses_anonymous_args = 0
 442 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 443              		.cfi_def_cfa_offset 24
 444              		.cfi_offset 4, -24
 445              		.cfi_offset 5, -20
 446              		.cfi_offset 6, -16
 447              		.cfi_offset 7, -12
 448              		.cfi_offset 8, -8
 449              		.cfi_offset 14, -4
  78:dfu.c         ****     dfuBusy = TRUE;
 450              		.loc 1 78 0
 451 0004 7949     		ldr	r1, .L98
  82:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 452              		.loc 1 82 0
 453 0006 7A4C     		ldr	r4, .L98+4
  78:dfu.c         ****     dfuBusy = TRUE;
 454              		.loc 1 78 0
 455 0008 0120     		movs	r0, #1
 456 000a 0870     		strb	r0, [r1]
  82:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 457              		.loc 1 82 0
 458 000c 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
  83:dfu.c         ****     dfuAppStatus.bStatus = OK;
 459              		.loc 1 83 0
 460 000e 0022     		movs	r2, #0
  82:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 461              		.loc 1 82 0
 462 0010 DBB2     		uxtb	r3, r3
 463              	.LVL20:
  85:dfu.c         ****     if (startState == dfuIDLE)  {
 464              		.loc 1 85 0
 465 0012 022B     		cmp	r3, #2
  83:dfu.c         ****     dfuAppStatus.bStatus = OK;
 466              		.loc 1 83 0
 467 0014 2270     		strb	r2, [r4]
  85:dfu.c         ****     if (startState == dfuIDLE)  {
 468              		.loc 1 85 0
 469 0016 4AD1     		bne	.L40
  87:dfu.c         ****         dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
 470              		.loc 1 87 0
 471 0018 0870     		strb	r0, [r1]
  89:dfu.c         ****         if (pInformation->USBbRequest == DFU_DNLOAD) {
 472              		.loc 1 89 0
 473 001a 7649     		ldr	r1, .L98+8
 474 001c 0968     		ldr	r1, [r1]
 475 001e 4878     		ldrb	r0, [r1, #1]	@ zero_extendqisi2
 476 0020 0128     		cmp	r0, #1
 477 0022 1AD1     		bne	.L41
  91:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 478              		.loc 1 91 0
 479 0024 CB88     		ldrh	r3, [r1, #6]
 480              	.LVL21:
 481 0026 002B     		cmp	r3, #0
 482 0028 00F0B580 		beq	.L71
  92:dfu.c         ****                 userFirmwareLen = 0;
 483              		.loc 1 92 0
 484 002c 724B     		ldr	r3, .L98+12
 485 002e 1A60     		str	r2, [r3]
  94:dfu.c         ****                 switch(pInformation->Current_AlternateSetting)
 486              		.loc 1 94 0
 487 0030 0A7B     		ldrb	r2, [r1, #12]	@ zero_extendqisi2
  93:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 488              		.loc 1 93 0
 489 0032 0323     		movs	r3, #3
 490 0034 2371     		strb	r3, [r4, #4]
  94:dfu.c         ****                 switch(pInformation->Current_AlternateSetting)
 491              		.loc 1 94 0
 492 0036 6AB9     		cbnz	r2, .L81
 105:dfu.c         ****                         userUploadType = DFU_UPLOAD_FLASH_0X8002000;
 493              		.loc 1 105 0
 494 0038 704A     		ldr	r2, .L98+16
 495 003a 1370     		strb	r3, [r2]
 106:dfu.c         ****                         userAppAddr = USER_CODE_FLASH0X8002000;
 496              		.loc 1 106 0
 497 003c 704A     		ldr	r2, .L98+20
 498 003e 714B     		ldr	r3, .L98+24
 499 0040 1A60     		str	r2, [r3]
 108:dfu.c         ****                         setupFLASH();
 500              		.loc 1 108 0
 501 0042 FFF7FEFF 		bl	setupFLASH
 502              	.LVL22:
 109:dfu.c         ****                         flashUnlock();
 503              		.loc 1 109 0
 504 0046 FFF7FEFF 		bl	flashUnlock
 505              	.LVL23:
 110:dfu.c         ****                         bkp10Write(RTC_BOOTLOADER_JUST_UPLOADED);
 506              		.loc 1 110 0
 507 004a 44F24D20 		movw	r0, #16973
 508 004e FFF7FEFF 		bl	bkp10Write
 509              	.LVL24:
 112:dfu.c         ****                         break;
 510              		.loc 1 112 0
 511 0052 C3E0     		b	.L45
 512              	.L81:
 153:dfu.c         ****                         dfuAppStatus.bState  = dfuERROR;
 513              		.loc 1 153 0
 514 0054 0A22     		movs	r2, #10
 515 0056 2271     		strb	r2, [r4, #4]
 516 0058 BFE0     		b	.L84
 517              	.LVL25:
 518              	.L41:
 161:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_UPLOAD) {
 519              		.loc 1 161 0
 520 005a 0228     		cmp	r0, #2
 521 005c 21D1     		bne	.L46
 162:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 522              		.loc 1 162 0
 523 005e 0923     		movs	r3, #9
 524              	.LVL26:
 525 0060 2371     		strb	r3, [r4, #4]
 165:dfu.c         ****             uploadBlockLen = pInformation->USBwLengths.w;
 526              		.loc 1 165 0
 527 0062 CA88     		ldrh	r2, [r1, #6]
 528 0064 684B     		ldr	r3, .L98+28
 529 0066 1A80     		strh	r2, [r3]	@ movhi
 166:dfu.c         ****             thisBlockLen = uploadBlockLen; /* for this first block as well */
 530              		.loc 1 166 0
 531 0068 1888     		ldrh	r0, [r3]
 532 006a 684A     		ldr	r2, .L98+32
 533 006c 80B2     		uxth	r0, r0
 534 006e 1080     		strh	r0, [r2]	@ movhi
 168:dfu.c         ****             userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 535              		.loc 1 168 0
 536 0070 1A88     		ldrh	r2, [r3]
 537 0072 4B88     		ldrh	r3, [r1, #2]
 538 0074 92B2     		uxth	r2, r2
 539 0076 5A43     		muls	r2, r3, r2
 540 0078 5F4B     		ldr	r3, .L98+12
 541 007a 1A60     		str	r2, [r3]
 169:dfu.c         ****             switch(pInformation->Current_AlternateSetting)
 542              		.loc 1 169 0
 543 007c 0B7B     		ldrb	r3, [r1, #12]	@ zero_extendqisi2
 544 007e 012B     		cmp	r3, #1
 545 0080 03D0     		beq	.L48
 546 0082 022B     		cmp	r3, #2
 547 0084 09D1     		bne	.L97
 191:dfu.c         ****                     userAppAddr = USER_CODE_FLASH0X8002000;
 548              		.loc 1 191 0
 549 0086 5E4A     		ldr	r2, .L98+20
 550 0088 00E0     		b	.L83
 551              	.L48:
 187:dfu.c         ****                     userAppAddr = USER_CODE_FLASH0X8005000;
 552              		.loc 1 187 0
 553 008a 614A     		ldr	r2, .L98+36
 554              	.L83:
 191:dfu.c         ****                     userAppAddr = USER_CODE_FLASH0X8002000;
 555              		.loc 1 191 0
 556 008c 5D4B     		ldr	r3, .L98+24
 557 008e 1A60     		str	r2, [r3]
 192:dfu.c         ****                     userAppEnd = getFlashEnd();
 558              		.loc 1 192 0
 559 0090 FFF7FEFF 		bl	getFlashEnd
 560              	.LVL27:
 561 0094 5F4B     		ldr	r3, .L98+40
 562 0096 1860     		str	r0, [r3]
 193:dfu.c         ****                     break;
 563              		.loc 1 193 0
 564 0098 A0E0     		b	.L45
 565              	.L97:
 199:dfu.c         ****                     dfuAppStatus.bState  = dfuERROR;
 566              		.loc 1 199 0
 567 009a 0A23     		movs	r3, #10
 568 009c 2371     		strb	r3, [r4, #4]
 200:dfu.c         ****                     dfuAppStatus.bStatus = errWRITE;
 569              		.loc 1 200 0
 570 009e 0323     		movs	r3, #3
 571 00a0 9BE0     		b	.L84
 572              	.LVL28:
 573              	.L46:
 203:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 574              		.loc 1 203 0
 575 00a2 0628     		cmp	r0, #6
 576 00a4 3CD0     		beq	.L87
 206:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 577              		.loc 1 206 0
 578 00a6 0328     		cmp	r0, #3
 579 00a8 19D0     		beq	.L86
 208:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 580              		.loc 1 208 0
 581 00aa 0528     		cmp	r0, #5
 582 00ac 3CE0     		b	.L93
 583              	.L40:
 215:dfu.c         ****     } else if (startState == dfuDNLOAD_SYNC)         {
 584              		.loc 1 215 0
 585 00ae 032B     		cmp	r3, #3
 586 00b0 0BD1     		bne	.L53
 218:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 587              		.loc 1 218 0
 588 00b2 504A     		ldr	r2, .L98+8
 589 00b4 1268     		ldr	r2, [r2]
 590 00b6 5278     		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 591 00b8 032A     		cmp	r2, #3
 592 00ba 04D1     		bne	.L54
 247:dfu.c         ****                 dfuAppStatus.bState = dfuDNLOAD_IDLE;
 593              		.loc 1 247 0
 594 00bc 0523     		movs	r3, #5
 595              	.LVL29:
 596 00be 2371     		strb	r3, [r4, #4]
 248:dfu.c         ****                 dfuCopyBufferToExec();
 597              		.loc 1 248 0
 598 00c0 FFF7FEFF 		bl	dfuCopyBufferToExec
 599              	.LVL30:
 600 00c4 8AE0     		b	.L45
 601              	.LVL31:
 602              	.L54:
 251:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 603              		.loc 1 251 0
 604 00c6 052A     		cmp	r2, #5
 605 00c8 2EE0     		b	.L93
 606              	.L53:
 258:dfu.c         ****     } else if (startState == dfuDNBUSY)              {
 607              		.loc 1 258 0
 608 00ca 042B     		cmp	r3, #4
 609 00cc 09D1     		bne	.L56
 260:dfu.c         ****         if (code_copy_lock == END) {
 610              		.loc 1 260 0
 611 00ce 5249     		ldr	r1, .L98+44
 612 00d0 0878     		ldrb	r0, [r1]	@ zero_extendqisi2
 613 00d2 0228     		cmp	r0, #2
 614 00d4 03D1     		bne	.L86
 262:dfu.c         ****             code_copy_lock = WAIT;
 615              		.loc 1 262 0
 616 00d6 0323     		movs	r3, #3
 617              	.LVL32:
 261:dfu.c         ****             dfuAppStatus.bwPollTimeout0 = 0x00;
 618              		.loc 1 261 0
 619 00d8 6270     		strb	r2, [r4, #1]
 262:dfu.c         ****             code_copy_lock = WAIT;
 620              		.loc 1 262 0
 621 00da 0B70     		strb	r3, [r1]
 263:dfu.c         ****             dfuAppStatus.bState = dfuDNLOAD_IDLE;
 622              		.loc 1 263 0
 623 00dc 0523     		movs	r3, #5
 624              	.L86:
 625 00de 2371     		strb	r3, [r4, #4]
 626 00e0 7CE0     		b	.L45
 627              	.LVL33:
 628              	.L56:
 268:dfu.c         ****     } else if (startState == dfuDNLOAD_IDLE)         {
 629              		.loc 1 268 0
 630 00e2 052B     		cmp	r3, #5
 631 00e4 14D1     		bne	.L58
 270:dfu.c         ****         if (pInformation->USBbRequest == DFU_DNLOAD) {
 632              		.loc 1 270 0
 633 00e6 434B     		ldr	r3, .L98+8
 634              	.LVL34:
 635 00e8 1A68     		ldr	r2, [r3]
 636 00ea 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 637 00ec 012B     		cmp	r3, #1
 638 00ee 08D1     		bne	.L59
 271:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 639              		.loc 1 271 0
 640 00f0 D388     		ldrh	r3, [r2, #6]
 641 00f2 0BB1     		cbz	r3, .L60
 272:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 642              		.loc 1 272 0
 643 00f4 0323     		movs	r3, #3
 644 00f6 F2E7     		b	.L86
 645              	.L60:
 275:dfu.c         ****                 dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 646              		.loc 1 275 0
 647 00f8 0623     		movs	r3, #6
 648 00fa 2371     		strb	r3, [r4, #4]
 278:dfu.c         ****                 flashLock();
 649              		.loc 1 278 0
 650 00fc FFF7FEFF 		bl	flashLock
 651              	.LVL35:
 652 0100 6CE0     		b	.L45
 653              	.L59:
 280:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 654              		.loc 1 280 0
 655 0102 062B     		cmp	r3, #6
 656 0104 4DD0     		beq	.L96
 282:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 657              		.loc 1 282 0
 658 0106 032B     		cmp	r3, #3
 659 0108 4BD0     		beq	.L96
 284:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 660              		.loc 1 284 0
 661 010a 052B     		cmp	r3, #5
 662 010c 62D1     		bne	.L77
 663 010e 48E0     		b	.L96
 664              	.LVL36:
 665              	.L58:
 291:dfu.c         ****     } else if (startState == dfuMANIFEST_SYNC)       {
 666              		.loc 1 291 0
 667 0110 062B     		cmp	r3, #6
 668 0112 0BD1     		bne	.L64
 294:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 669              		.loc 1 294 0
 670 0114 3749     		ldr	r1, .L98+8
 671 0116 0968     		ldr	r1, [r1]
 672 0118 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 673 011a 0329     		cmp	r1, #3
 674 011c 03D1     		bne	.L65
 675              	.L88:
 295:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 676              		.loc 1 295 0
 677 011e 0823     		movs	r3, #8
 678              	.LVL37:
 679              	.L87:
 680 0120 2371     		strb	r3, [r4, #4]
 296:dfu.c         ****             dfuAppStatus.bStatus = OK;
 681              		.loc 1 296 0
 682 0122 2270     		strb	r2, [r4]
 683 0124 5AE0     		b	.L45
 684              	.LVL38:
 685              	.L65:
 297:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 686              		.loc 1 297 0
 687 0126 0529     		cmp	r1, #5
 688              	.L93:
 689 0128 54D1     		bne	.L77
 690 012a D8E7     		b	.L86
 691              	.L64:
 304:dfu.c         ****     } else if (startState == dfuMANIFEST)            {
 692              		.loc 1 304 0
 693 012c 072B     		cmp	r3, #7
 694 012e F6D0     		beq	.L88
 311:dfu.c         ****     } else if (startState == dfuMANIFEST_WAIT_RESET) {
 695              		.loc 1 311 0
 696 0130 082B     		cmp	r3, #8
 697 0132 D4D0     		beq	.L86
 318:dfu.c         ****     } else if (startState == dfuUPLOAD_IDLE)         {
 698              		.loc 1 318 0
 699 0134 092B     		cmp	r3, #9
 700 0136 3CD1     		bne	.L69
 321:dfu.c         ****         if (pInformation->USBbRequest == DFU_UPLOAD) {
 701              		.loc 1 321 0
 702 0138 2E4B     		ldr	r3, .L98+8
 703              	.LVL39:
 704 013a 1A68     		ldr	r2, [r3]
 705 013c 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 706 013e 022B     		cmp	r3, #2
 707 0140 2DD1     		bne	.L70
 322:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 708              		.loc 1 322 0
 709 0142 D088     		ldrh	r0, [r2, #6]
 710 0144 38B3     		cbz	r0, .L71
 324:dfu.c         ****                 userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 711              		.loc 1 324 0
 712 0146 3049     		ldr	r1, .L98+28
 713 0148 5288     		ldrh	r2, [r2, #2]
 714 014a 0B88     		ldrh	r3, [r1]
 325:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 715              		.loc 1 325 0
 716 014c 2D4D     		ldr	r5, .L98+24
 324:dfu.c         ****                 userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 717              		.loc 1 324 0
 718 014e 9BB2     		uxth	r3, r3
 719 0150 5343     		muls	r3, r2, r3
 720 0152 294A     		ldr	r2, .L98+12
 325:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 721              		.loc 1 325 0
 722 0154 2F4E     		ldr	r6, .L98+40
 324:dfu.c         ****                 userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 723              		.loc 1 324 0
 724 0156 1360     		str	r3, [r2]
 325:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 725              		.loc 1 325 0
 726 0158 2F68     		ldr	r7, [r5]
 727 015a D2F80080 		ldr	r8, [r2]
 728 015e B1F800C0 		ldrh	ip, [r1]
 729 0162 4744     		add	r7, r7, r8
 730 0164 3368     		ldr	r3, [r6]
 731 0166 1FFA8CFC 		uxth	ip, ip
 732 016a 6744     		add	r7, r7, ip
 733 016c 9F42     		cmp	r7, r3
 734 016e 274B     		ldr	r3, .L98+32
 735 0170 03D8     		bhi	.L72
 326:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 736              		.loc 1 326 0
 737 0172 0A88     		ldrh	r2, [r1]
 738 0174 92B2     		uxth	r2, r2
 739 0176 1A80     		strh	r2, [r3]	@ movhi
 740 0178 19E0     		b	.L95
 741              	.L72:
 331:dfu.c         ****                     thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
 742              		.loc 1 331 0
 743 017a 3668     		ldr	r6, [r6]
 744 017c 2D68     		ldr	r5, [r5]
 745 017e 1168     		ldr	r1, [r2]
 746 0180 721B     		subs	r2, r6, r5
 747 0182 521A     		subs	r2, r2, r1
 748 0184 92B2     		uxth	r2, r2
 749 0186 1A80     		strh	r2, [r3]	@ movhi
 333:dfu.c         ****                     if (thisBlockLen >= pInformation->USBwLengths.w) {
 750              		.loc 1 333 0
 751 0188 1A88     		ldrh	r2, [r3]
 752 018a 92B2     		uxth	r2, r2
 753 018c 8242     		cmp	r2, r0
 754 018e 08D3     		bcc	.L96
 334:dfu.c         ****                         thisBlockLen = 0;
 755              		.loc 1 334 0
 756 0190 0022     		movs	r2, #0
 757 0192 1A80     		strh	r2, [r3]	@ movhi
 758 0194 05E0     		b	.L96
 759              	.L71:
 339:dfu.c         ****                 dfuAppStatus.bState  = dfuERROR;
 760              		.loc 1 339 0
 761 0196 0A23     		movs	r3, #10
 762 0198 2371     		strb	r3, [r4, #4]
 340:dfu.c         ****                 dfuAppStatus.bStatus = errNOTDONE;
 763              		.loc 1 340 0
 764 019a 0923     		movs	r3, #9
 765 019c 1DE0     		b	.L84
 766              	.L70:
 342:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 767              		.loc 1 342 0
 768 019e 062B     		cmp	r3, #6
 769 01a0 01D1     		bne	.L74
 770              	.L96:
 343:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 771              		.loc 1 343 0
 772 01a2 0223     		movs	r3, #2
 773 01a4 9BE7     		b	.L86
 774              	.L74:
 344:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 775              		.loc 1 344 0
 776 01a6 032B     		cmp	r3, #3
 777 01a8 01D0     		beq	.L95
 346:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 778              		.loc 1 346 0
 779 01aa 052B     		cmp	r3, #5
 780 01ac 12D1     		bne	.L77
 781              	.L95:
 347:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 782              		.loc 1 347 0
 783 01ae 0923     		movs	r3, #9
 784 01b0 95E7     		b	.L86
 785              	.LVL40:
 786              	.L69:
 354:dfu.c         ****     } else if (startState == dfuERROR)               {
 787              		.loc 1 354 0
 788 01b2 0A2B     		cmp	r3, #10
 789 01b4 0ED1     		bne	.L77
 357:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 790              		.loc 1 357 0
 791 01b6 0F4B     		ldr	r3, .L98+8
 792              	.LVL41:
 793 01b8 1B68     		ldr	r3, [r3]
 794 01ba 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 795 01bc 032B     		cmp	r3, #3
 796 01be 01D1     		bne	.L78
 797              	.L91:
 359:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 798              		.loc 1 359 0
 799 01c0 0A23     		movs	r3, #10
 800 01c2 8CE7     		b	.L86
 801              	.L78:
 360:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 802              		.loc 1 360 0
 803 01c4 052B     		cmp	r3, #5
 804 01c6 FBD0     		beq	.L91
 362:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
 805              		.loc 1 362 0
 806 01c8 042B     		cmp	r3, #4
 807 01ca 03D1     		bne	.L77
 364:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 808              		.loc 1 364 0
 809 01cc 0223     		movs	r3, #2
 810 01ce 2371     		strb	r3, [r4, #4]
 365:dfu.c         ****             dfuAppStatus.bStatus = OK;
 811              		.loc 1 365 0
 812 01d0 0023     		movs	r3, #0
 813 01d2 02E0     		b	.L84
 814              	.L77:
 373:dfu.c         ****         dfuAppStatus.bState  = dfuERROR;
 815              		.loc 1 373 0
 816 01d4 0A23     		movs	r3, #10
 817 01d6 2371     		strb	r3, [r4, #4]
 374:dfu.c         ****         dfuAppStatus.bStatus = errSTALLEDPKT;
 818              		.loc 1 374 0
 819 01d8 0F23     		movs	r3, #15
 820              	.L84:
 821 01da 2370     		strb	r3, [r4]
 822              	.L45:
 377:dfu.c         ****     if (dfuAppStatus.bStatus == OK) {
 823              		.loc 1 377 0
 824 01dc 2078     		ldrb	r0, [r4]	@ zero_extendqisi2
 382:dfu.c         **** }
 825              		.loc 1 382 0
 826 01de D0F10100 		rsbs	r0, r0, #1
 827 01e2 38BF     		it	cc
 828 01e4 0020     		movcc	r0, #0
 829 01e6 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 830              	.L99:
 831 01ea 00BF     		.align	2
 832              	.L98:
 833 01ec 00000000 		.word	.LANCHOR6
 834 01f0 00000000 		.word	.LANCHOR0
 835 01f4 00000000 		.word	pInformation
 836 01f8 00000000 		.word	.LANCHOR1
 837 01fc 00000000 		.word	.LANCHOR5
 838 0200 00200008 		.word	134225920
 839 0204 00000000 		.word	.LANCHOR3
 840 0208 00000000 		.word	.LANCHOR8
 841 020c 00000000 		.word	.LANCHOR2
 842 0210 00500008 		.word	134238208
 843 0214 00000000 		.word	.LANCHOR4
 844 0218 00000000 		.word	code_copy_lock
 845              		.cfi_endproc
 846              	.LFE1:
 848              		.section	.text.dfuGetState,"ax",%progbits
 849              		.align	1
 850              		.global	dfuGetState
 851              		.thumb
 852              		.thumb_func
 854              	dfuGetState:
 855              	.LFB9:
 487:dfu.c         **** }
 488:dfu.c         **** 
 489:dfu.c         **** u8 dfuGetState(void) {
 856              		.loc 1 489 0
 857              		.cfi_startproc
 858              		@ args = 0, pretend = 0, frame = 0
 859              		@ frame_needed = 0, uses_anonymous_args = 0
 860              		@ link register save eliminated.
 490:dfu.c         ****     return dfuAppStatus.bState;
 861              		.loc 1 490 0
 862 0000 014B     		ldr	r3, .L101
 863 0002 1879     		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 491:dfu.c         **** }
 864              		.loc 1 491 0
 865 0004 7047     		bx	lr
 866              	.L102:
 867 0006 00BF     		.align	2
 868              	.L101:
 869 0008 00000000 		.word	.LANCHOR0
 870              		.cfi_endproc
 871              	.LFE9:
 873              		.section	.text.dfuSetState,"ax",%progbits
 874              		.align	1
 875              		.global	dfuSetState
 876              		.thumb
 877              		.thumb_func
 879              	dfuSetState:
 880              	.LFB10:
 492:dfu.c         **** 
 493:dfu.c         **** void dfuSetState(u8 newState) {
 881              		.loc 1 493 0
 882              		.cfi_startproc
 883              		@ args = 0, pretend = 0, frame = 0
 884              		@ frame_needed = 0, uses_anonymous_args = 0
 885              		@ link register save eliminated.
 886              	.LVL42:
 494:dfu.c         ****     dfuAppStatus.bState = newState;
 887              		.loc 1 494 0
 888 0000 014B     		ldr	r3, .L104
 889 0002 1871     		strb	r0, [r3, #4]
 890 0004 7047     		bx	lr
 891              	.L105:
 892 0006 00BF     		.align	2
 893              	.L104:
 894 0008 00000000 		.word	.LANCHOR0
 895              		.cfi_endproc
 896              	.LFE10:
 898              		.section	.text.dfuUploadStarted,"ax",%progbits
 899              		.align	1
 900              		.global	dfuUploadStarted
 901              		.thumb
 902              		.thumb_func
 904              	dfuUploadStarted:
 905              	.LFB11:
 495:dfu.c         **** }
 496:dfu.c         **** 
 497:dfu.c         **** bool dfuUploadStarted() {
 906              		.loc 1 497 0
 907              		.cfi_startproc
 908              		@ args = 0, pretend = 0, frame = 0
 909              		@ frame_needed = 0, uses_anonymous_args = 0
 910              		@ link register save eliminated.
 498:dfu.c         ****     return dfuBusy;
 911              		.loc 1 498 0
 912 0000 014B     		ldr	r3, .L107
 913 0002 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 499:dfu.c         **** }
 914              		.loc 1 499 0
 915 0004 7047     		bx	lr
 916              	.L108:
 917 0006 00BF     		.align	2
 918              	.L107:
 919 0008 00000000 		.word	.LANCHOR6
 920              		.cfi_endproc
 921              	.LFE11:
 923              		.section	.text.dfuFinishUpload,"ax",%progbits
 924              		.align	1
 925              		.global	dfuFinishUpload
 926              		.thumb
 927              		.thumb_func
 929              	dfuFinishUpload:
 930              	.LFB12:
 500:dfu.c         **** 
 501:dfu.c         **** void dfuFinishUpload() {
 931              		.loc 1 501 0
 932              		.cfi_startproc
 933              		@ Volatile: function does not return.
 934              		@ args = 0, pretend = 0, frame = 0
 935              		@ frame_needed = 0, uses_anonymous_args = 0
 936              		@ link register save eliminated.
 937              	.L110:
 502:dfu.c         ****     while (1)
 503:dfu.c         ****     {
 504:dfu.c         ****         __asm("nop");
 938              		.loc 1 504 0 discriminator 1
 939              	@ 504 "dfu.c" 1
 940 0000 00BF     		nop
 941              	@ 0 "" 2
 942              		.thumb
 943 0002 FDE7     		b	.L110
 944              		.cfi_endproc
 945              	.LFE12:
 947              		.comm	code_copy_lock,1,1
 948              		.global	dfuBusy
 949              		.global	userUploadType
 950              		.comm	wTransferSize,4,4
 951              		.section	.bss.recvBuffer,"aw",%nobits
 952              		.align	2
 953              		.set	.LANCHOR7,. + 0
 956              	recvBuffer:
 957 0000 00000000 		.space	2048
 957      00000000 
 957      00000000 
 957      00000000 
 957      00000000 
 958              		.section	.bss.uploadBlockLen,"aw",%nobits
 959              		.align	1
 960              		.set	.LANCHOR8,. + 0
 963              	uploadBlockLen:
 964 0000 0000     		.space	2
 965              		.section	.bss.thisBlockLen,"aw",%nobits
 966              		.align	1
 967              		.set	.LANCHOR2,. + 0
 970              	thisBlockLen:
 971 0000 0000     		.space	2
 972              		.section	.bss.userFirmwareLen,"aw",%nobits
 973              		.align	2
 974              		.set	.LANCHOR1,. + 0
 977              	userFirmwareLen:
 978 0000 00000000 		.space	4
 979              		.section	.data.userAppEnd,"aw",%progbits
 980              		.align	2
 981              		.set	.LANCHOR4,. + 0
 984              	userAppEnd:
 985 0000 00500020 		.word	536891392
 986              		.section	.bss.userUploadType,"aw",%nobits
 987              		.set	.LANCHOR5,. + 0
 990              	userUploadType:
 991 0000 00       		.space	1
 992              		.section	.bss.dfuAppStatus,"aw",%nobits
 993              		.set	.LANCHOR0,. + 0
 996              	dfuAppStatus:
 997 0000 00000000 		.space	6
 997      0000
 998              		.section	.bss.dfuBusy,"aw",%nobits
 999              		.set	.LANCHOR6,. + 0
 1002              	dfuBusy:
 1003 0000 00       		.space	1
 1004              		.section	.data.userAppAddr,"aw",%progbits
 1005              		.align	2
 1006              		.set	.LANCHOR3,. + 0
 1009              	userAppAddr:
 1010 0000 000C0020 		.word	536873984
 1011              		.text
 1012              	.Letext0:
 1013              		.file 2 "./stm32_lib/stm32f10x_type.h"
 1014              		.file 3 "./usb_lib/usb_core.h"
 1015              		.file 4 "dfu.h"
 1016              		.file 5 "./usb_lib/usb_init.h"
 1017              		.file 6 "usb.h"
 1018              		.file 7 "hardware.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 dfu.c
     /tmp/cc71nvgf.s:19     .text.dfuInit:0000000000000000 $t
     /tmp/cc71nvgf.s:24     .text.dfuInit:0000000000000000 dfuInit
     /tmp/cc71nvgf.s:81     .text.dfuInit:0000000000000038 $d
                            *COM*:0000000000000001 code_copy_lock
     /tmp/cc71nvgf.s:94     .text.dfuUpdateByReset:0000000000000000 $t
     /tmp/cc71nvgf.s:99     .text.dfuUpdateByReset:0000000000000000 dfuUpdateByReset
     /tmp/cc71nvgf.s:160    .text.dfuUpdateByReset:000000000000003c $d
     /tmp/cc71nvgf.s:166    .text.dfuUpdateByTimeout:0000000000000000 $t
     /tmp/cc71nvgf.s:171    .text.dfuUpdateByTimeout:0000000000000000 dfuUpdateByTimeout
     /tmp/cc71nvgf.s:183    .text.dfuCopyState:0000000000000000 $t
     /tmp/cc71nvgf.s:188    .text.dfuCopyState:0000000000000000 dfuCopyState
     /tmp/cc71nvgf.s:214    .text.dfuCopyState:0000000000000010 $d
     /tmp/cc71nvgf.s:220    .text.dfuCopyStatus:0000000000000000 $t
     /tmp/cc71nvgf.s:225    .text.dfuCopyStatus:0000000000000000 dfuCopyStatus
     /tmp/cc71nvgf.s:251    .text.dfuCopyStatus:0000000000000010 $d
     /tmp/cc71nvgf.s:257    .text.dfuCopyDNLOAD:0000000000000000 $t
     /tmp/cc71nvgf.s:262    .text.dfuCopyDNLOAD:0000000000000000 dfuCopyDNLOAD
     /tmp/cc71nvgf.s:296    .text.dfuCopyDNLOAD:000000000000001c $d
     /tmp/cc71nvgf.s:303    .text.dfuCopyUPLOAD:0000000000000000 $t
     /tmp/cc71nvgf.s:308    .text.dfuCopyUPLOAD:0000000000000000 dfuCopyUPLOAD
     /tmp/cc71nvgf.s:344    .text.dfuCopyUPLOAD:0000000000000024 $d
     /tmp/cc71nvgf.s:352    .text.dfuCopyBufferToExec:0000000000000000 $t
     /tmp/cc71nvgf.s:357    .text.dfuCopyBufferToExec:0000000000000000 dfuCopyBufferToExec
     /tmp/cc71nvgf.s:423    .text.dfuCopyBufferToExec:000000000000004c $d
     /tmp/cc71nvgf.s:431    .text.dfuUpdateByRequest:0000000000000000 $t
     /tmp/cc71nvgf.s:436    .text.dfuUpdateByRequest:0000000000000000 dfuUpdateByRequest
     /tmp/cc71nvgf.s:833    .text.dfuUpdateByRequest:00000000000001ec $d
     /tmp/cc71nvgf.s:849    .text.dfuGetState:0000000000000000 $t
     /tmp/cc71nvgf.s:854    .text.dfuGetState:0000000000000000 dfuGetState
     /tmp/cc71nvgf.s:869    .text.dfuGetState:0000000000000008 $d
     /tmp/cc71nvgf.s:874    .text.dfuSetState:0000000000000000 $t
     /tmp/cc71nvgf.s:879    .text.dfuSetState:0000000000000000 dfuSetState
     /tmp/cc71nvgf.s:894    .text.dfuSetState:0000000000000008 $d
     /tmp/cc71nvgf.s:899    .text.dfuUploadStarted:0000000000000000 $t
     /tmp/cc71nvgf.s:904    .text.dfuUploadStarted:0000000000000000 dfuUploadStarted
     /tmp/cc71nvgf.s:919    .text.dfuUploadStarted:0000000000000008 $d
     /tmp/cc71nvgf.s:924    .text.dfuFinishUpload:0000000000000000 $t
     /tmp/cc71nvgf.s:929    .text.dfuFinishUpload:0000000000000000 dfuFinishUpload
     /tmp/cc71nvgf.s:1002   .bss.dfuBusy:0000000000000000 dfuBusy
     /tmp/cc71nvgf.s:990    .bss.userUploadType:0000000000000000 userUploadType
                            *COM*:0000000000000004 wTransferSize
     /tmp/cc71nvgf.s:952    .bss.recvBuffer:0000000000000000 $d
     /tmp/cc71nvgf.s:956    .bss.recvBuffer:0000000000000000 recvBuffer
     /tmp/cc71nvgf.s:959    .bss.uploadBlockLen:0000000000000000 $d
     /tmp/cc71nvgf.s:963    .bss.uploadBlockLen:0000000000000000 uploadBlockLen
     /tmp/cc71nvgf.s:966    .bss.thisBlockLen:0000000000000000 $d
     /tmp/cc71nvgf.s:970    .bss.thisBlockLen:0000000000000000 thisBlockLen
     /tmp/cc71nvgf.s:973    .bss.userFirmwareLen:0000000000000000 $d
     /tmp/cc71nvgf.s:977    .bss.userFirmwareLen:0000000000000000 userFirmwareLen
     /tmp/cc71nvgf.s:980    .data.userAppEnd:0000000000000000 $d
     /tmp/cc71nvgf.s:984    .data.userAppEnd:0000000000000000 userAppEnd
     /tmp/cc71nvgf.s:991    .bss.userUploadType:0000000000000000 $d
     /tmp/cc71nvgf.s:996    .bss.dfuAppStatus:0000000000000000 dfuAppStatus
     /tmp/cc71nvgf.s:997    .bss.dfuAppStatus:0000000000000000 $d
     /tmp/cc71nvgf.s:1003   .bss.dfuBusy:0000000000000000 $d
     /tmp/cc71nvgf.s:1005   .data.userAppAddr:0000000000000000 $d
     /tmp/cc71nvgf.s:1009   .data.userAppAddr:0000000000000000 userAppAddr
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
nvicDisableInterrupts
usbEnbISR
systemHardReset
pInformation
flashErasePage
flashWriteWord
setupFLASH
flashUnlock
bkp10Write
getFlashEnd
flashLock
